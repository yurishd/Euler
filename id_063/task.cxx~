#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <algorithm>
#include <iterator>

using namespace std;

struct Helper_t
{
  long m_prime;
  long m_count;

  Helper_t() : m_prime(0), m_count(0) {}
  Helper_t(long prime) : m_prime(prime), m_count(1) {}

  bool operator==(Helper_t const &other)
  { return ((m_prime == other.m_prime) && (m_count == other.m_count)); }
};

ostream& operator<<(ostream &os, Helper_t const& hlp);

bool build_prime_divisors(vector<Helper_t>&prime_divisors,
                          vector<long>&primes,
                          long trgN);

int main(int argc, char *argv[])
{
  vector<long> primes;
  long tmp;
  ifstream is("../primes_1mil.txt");
  is >> tmp;
  while (is) {
    primes.push_back(tmp);
    is >> tmp;
  }
  primes.push_back(tmp);

  long sum = 0;
  vector<Helper_t>&prime_divisors;
  for (long i = 0; i < 9999999999; ++i) {
    if (build_prime_divisors(prime_divisors, primes, i)) {
      cout << i << " = " << prime_divisors[0] << endl;
      return 0;
    }
  }
  cout << " NEVER FINISH"  << endl;
  return 0;
}

void build_prime_divisors(vector<Helper_t>&prime_divisors,
                          vector<long>&primes,
                          long trgN)
{
  int power = 1;
  long tmp = trgN/10;
  while (tmp > 0) {
    ++power;
    tmp /= 10;
  }
  size_t prsz = primes.size();
  size_t pri = 0;
  size_t prev_pri = 0xFFFFFFFF;
  prime_divisors.clear();
  long modulo;
  long count = 0;
  while (pri < prsz) {
    if (trgN < primes[pri]) return;
    modulo = trgN % primes[pri];
    //cout << trgN << "%" << primes[pri] << " = " << modulo << endl;
    if ( modulo == 0) {
      trgN /= primes[pri];
      if (pri == prev_pri) {
        ++prime_divisors[prime_divisors.size()-1].m_count;
      } else {
        prev_pri = pri;
        prime_divisors.push_back(Helper_t(primes[pri]));
        if (!(prime_divisors[counter].m_count % 10)) {
          return false;
        }
        ++count;
      }
    } else {
      ++pri;
    }
  }
}

ostream& operator<<(ostream &os, Helper_t const& hlp)
{
  os << hlp.m_prime << "^" << hlp.m_count;
  return os;
}

bool check_and_apply(vector<Helper_t>&all_divisors,
                     vector<Helper_t>&new_divisors)
{
  size_t sz = all_divisors.size();
  for (size_t isz = 0; isz < new_divisors.size(); ++isz) {
    for (size_t jsz = 0; jsz < sz; ++jsz) {
      if (new_divisors[isz] == all_divisors[jsz]) return false;
    }
    all_divisors.push_back(new_divisors[isz]);
  }
  return true;
}
