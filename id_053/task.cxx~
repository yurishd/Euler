#include <iostream>
#include <set>
#include <vector>
#include <fstream>
#include <algorithm>
#include <iterator>
#include <math.h>

using namespace std;

void build_factorial_in_primes(vector<long> const &primes,
                               vector<long> &out, long N);
void add_factorial_in_primes(vector<long> const &primes,
                               vector<long> &out, long N);
bool calc(vector<long> const &primes,
          vector<long> const &nominator,
          vector<long> &dom1,
          vector<long> &dom2);

int main(int argc, char* argv[])
{
  long tmp;
  vector<long> primes;

  ifstream is("../primes_1mil.txt");
  is >> tmp;
  while (is) {
    primes.push_back(tmp);
    is >> tmp;
  }
  primes.push_back(tmp);

  vector<long> main_factorial;
  vector<long> tmp_factorial1;
  vector<long> tmp_factorial2;

  build_factorial_in_primes(primes, main_factorial, 23);
  long result = 4;
  for (int i = 24; i < 101; ++i) {
    add_factorial_in_primes(primes, main_factorial, i);
    int max_m = i/2;
    int coeff = (i % 2 == 0 ? 1 : 2);
    for (int j = max_m; j > 0; --j) {
      build_factorial_in_primes(primes, tmp_factorial1, j);
      build_factorial_in_primes(primes, tmp_factorial2, i - j);
      if (calc(primes, main_factorial, tmp_factorial1, tmp_factorial2)) {
        result += coeff;
      } else {
        break;
      }
      coeff = 2;
    }
  }
  cout << result << endl;
  return 0;
}

void build_factorial_in_primes(vector<long> const &primes,
                               vector<long> &out, long N)
{
  out.clear();
  for (long i = 2; i <= N; ++i) {
    add_factorial_in_primes(primes, out, i);
  }
}

void add_factorial_in_primes(vector<long> const &primes,
                               vector<long> &out, long N)
{
  vector<long> atmp;
  size_t isz = 0;
  atmp.push_back(0);

  long new_max = (long)sqrt((double)N);
  while(primes[isz] <= new_max) {
    if (0 == N % primes[isz]) {
      ++atmp[isz];
      N /= primes[isz];
    } else {
      ++isz;
      atmp.push_back(0);
    }
  }
  while (atmp.size() && (0 == atmp[atmp.size() - 1])) {
    atmp.pop_back();
  }
  if (out.size() < atmp.size()) {
    for (isz = 0; isz < out.size(); ++isz) {
      out[isz] += atmp[isz];
    }
    while (out.size() < atmp.size()) {
      isz = out.size();
      out.push_back(atmp[isz]);
    }
  } else {
    for (isz = 0; isz < atmp.size(); ++isz) {
      out[isz] += atmp[isz];
    }
  }
}

bool calc(vector<long> const &primes,
          vector<long> const &nominator,
          vector<long> &dom1,
          vector<long> &dom2)
{
  vector<long> *pdom = &dom1;
  size_t isz;
  if (dom1.size() <  dom2.size()) {
    for (isz = 0; isz < dom1.size(); ++isz) {
      dom2[isz] += dom1[isz];
    }
    pdom = &dom2;
  } else {
    for (isz = 0; isz < dom2.size(); ++isz) {
      dom1[isz] += dom2[isz];
    }
  }
  long result = 1;
  long tmp;
  for (isz = 0; isz < pdom->size(); ++isz) {
    tmp = nominator[isz] - (*pdom)[isz];
    for (size_t jsz = 0; jsz < tmp; ++jsz) {
      result *= primes[jsz];
    }
  }
  for (; isz < nominator.size(); ++isz) {
    for (size_t jsz = 0; jsz < nominator[isz]; ++jsz) {
      result *= primes[jsz];
    }
  }
  if (result > 1000000) return true;
  return false;
}
